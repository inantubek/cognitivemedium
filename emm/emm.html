<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Toward an exploratory medium for mathematics</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="prototype.css">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
      "HTML-CSS": 
      {scale: 92},
      TeX: { equationNumbers: { autoNumber: "AMS" }}});
    </script>
    <script type="text/javascript" src="mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- <script type="text/javascript" src="jquery/jquery-2.1.4.min.js"></script> -->
    <!-- My libraries, no longer needed since it's all been converted to (easily rewindable) video -->
    <!--
    <script type="text/javascript" src="emm.js"></script>
    <script type="text/javascript" src="prototype.js"></script>
    <script type="text/javascript" src="canvas.js"></script> -->
  </head>

  <body>
    <div id="header">
      <h1>Toward an exploratory medium for mathematics</h1>
      <p>
	<a href="http://michaelnielsen.org">Michael Nielsen</a> &nbsp; / &nbsp;
	<a href="http://www.recurse.com">Recurse Center</a> &nbsp; / &nbsp; February 2016
      </p>
    </div>

    <div id="container">

      <p>
	The world's oldest complete piece of surviving music is the
	3,400-year-old <a href="https://en.wikipedia.org/wiki/Hurrian_songs">Hurrian
	cult hymn</a>.  The hymn was found inscribed on clay tablets
	excavated from the ancient city of Ugarit, in modern-day
	Syria.  Sometime after the hymn was composed, the idea of
	using notation to record music was lost.  Writing two
	millennia later, in the seventh century CE, the polymath
	Isidore of Seville stated that &ldquo;unless [musical] sounds
	are held by the memory of man, they perish, because they
	cannot be written down.&rdquo;
      </p>

      <p>
	In the ninth century, European musicians began experimenting
	with notations to record plainchant.  The initial notations
	were rough.  They didn't precisely denote either pitch or
	rhythm, and were intended more as an aid to memory than as a
	recording medium.  But they improved.  In the 11th century,
	Guido of Arezzo introduced the musical staff, making it easy
	to record pitch.  And in the 13th century, Franco of Cologne
	suggested using a written note's appearance to signify
	duration.  These and many other ideas led to modern musical
	notation.
      </p>

      <p>
	Written music originated as a recording medium, but became a
	creative medium in its own right.  It made it much easier to
	compose complex, intricate music for many instruments and
	voices.  This paved the way for Bach's fugues, Beethoven's
	symphonies, and much else.  Written music became a medium for
	thought, a medium which expanded the range of musical ideas a
	composer could have, and thus changed music itself.  It's an
	example of a <em>cognitive medium</em> &ndash; a media
	environment to support and enable thought.
      </p>

      <p>
	In the modern day, digital computers have spurred the
	invention of many new cognitive media.  Consider a program
	such as Photoshop.  Adept users of Photoshop internalize tools
	such as the lasso, the eyedropper, the clone stamp, and so on.
	The tools become part of the way users think about image
	manipulation, and expand the range of graphical ideas they can
	have.
      </p>

      <p>
	Photoshop is just one of many cognitive media enabled by
	digital computers.  Other examples include musical
	scorewriting programs such as Finale and Sibelius, modeling
	programs such as Blender and 3ds Max, and game engines such as
	Unity and Unreal.  Such media enable users to think and create
	in ways that would otherwise be difficult or impossible.  They
	are ways of augmenting human
	intellect*<span class="marginnote">* This notion has been
	developed by many researchers.  See, for example, Douglas
	Engelbart's <a href="refs/Engelbart1962.pdf">Augmenting Human
	Intellect: A Conceptual Framework</a>, and Alan Kay and Adele
	Goldberg's <a href="refs/Kay1977.pdf">Personal Dynamic
	Media</a>.</span>.
      </p>

      <p>
	This essay is about the design of cognitive media for
	mathematics.  Examples of such cognitive media include
	Mathematica, Matlab, Sage, and Coq.  These programs are
	extremely useful, but conservative in that they represent
	mathematics in ways close to those used by mathematicians in
	(say) the 1950s, working with paper-and-pencil.  By contrast,
	in recent years many people*<span class="marginnote">* A
	partial list includes <a href="http://worrydream.com/">Bret
	Victor</a>, <a href="http://marctenbosch.com/">Marc ten
	Bosch</a>, and <a href="https://acko.net/about/">Steven
	Wittens</a>.</span>  have experimented with media which don't
	treat the basic language of mathematics as given, but rather
	use computers to change the fundamental representations and
	operations used.  Over the long run, I believe such
	experimentation will lead to radical changes in how we think
	about mathematics.
      </p>

      <p>
	As a step in this direction, in this essay I'll show a simple
	prototype medium which helps the user explore in a particular
	part of mathematics, namely, linear algebra.  The prototype is
	based on three main ideas:
      </p>

	<h3>1. A concrete, graphical medium based on direct
	manipulation</h3>

      <p>
	When using paper-and-pencil (or its
	close cousin, blackboard-and-chalk), mathematicians often
	explore using informal, concrete, graphical representations,
	like those shown in the image to the right.
	<img src="images/blackboard.jpg" width="350px" style="float:
	right; margin: 5px 0px 5px 10px;"/>
	<span class="marginnote" style="margin-top:
	32px;"><a href="https://commons.wikimedia.org/wiki/File:HD.3A.053_(10481714045).jpg">Photo
	credit:</a> United States Department of Energy.</span> Such
	exploration is often difficult in existing computer-based
	cognitive media.  While systems such as Mathematica are good
	at producing graphical output, they're not aimed primarily at
	direct manipulation of those graphical representations.  In
	this sense, they fall short of paper-and-pencil.  Is it
	possible to strictly improve on paper-and-pencil as a medium
	for doing mathematics?  Our prototype medium will aim to make
	direct manipulation easy.  The intent is to combine the
	flexibility and concreteness of paper-and-pencil with the
	automated inference that is the raison d'Ãªtre of traditional
	systems for doing mathematics by computer. Think something
	like &ldquo;Photoshop for linear algebra&rdquo;.  That grossly
	overstates what we'll achieve, but conveys the right gist.
      </p>

      <h3>2. A medium for exploration and discovery, not
	explanation</h3>
      
      <p>
	Many experimental cognitive media are intended
	as <em>explanations</em> &ndash; see, for a beautiful example,
	Vi Hart and Nicky
	Case's <a href="http://ncase.me/polygons/">explanation</a> of
	one of the economist Thomas
	Schelling's <a href="refs/Schelling1971a.pdf">models of social
	behavior</a>.  By contrast, the prototype medium we'll develop
	is intended as part of an open-ended environment for
	exploration and discovery.  Of course, exploration and
	discovery is a very different process to explanation, and so
	requires a different kind of medium.
      </p>

      <h3>3. Work on a genuine mathematical problem, not a toy
	or &ldquo;educational&rdquo; problem</h3>

      <p>
	We'll use our prototype to develop a piece of genuine
	mathematics, a beautiful result in linear algebra called
	the <em>singular value decomposition</em>, or <em>SVD</em> for
	short. This is in contrast to many experimental cognitive
	media, which often aim at toy mathematical problems.  Aiming
	at the SVD makes the essay less accessible than working with a
	toy problem, but has the great benefit of forcing us to
	confront and overcome the kind of problems which arise in real
	mathematical work.  In essence, we'll be using the medium to
	re-discover the SVD.  Of course, ideally we'd go even further
	than re-discovering existing mathematics, and use the medium
	to discover new mathematics.  We won't achieve that here, but
	over the long run, that's the right test of an exploratory
	cognitive medium: does it enable the development of important
	new ideas?
      </p>


	<h3>What do we learn about exploratory cognitive
	media?</h3>

      <p>
	The prototype itself is not the main point of the essay.
	Rather, the point is what general lessons we can learn from
	the prototype.  We'll use our prototype to identify a
	fundamental problem in the design of exploratory cognitive
	media.  This problem arises from desiring a medium that
	simultaneously: (1) automates computation and inference, as we
	expect a computer-based medium to do; and (2) allows the user
	to flexibly change assumptions on the fly, in a manner similar
	to paper-and-pencil.  We will show that such a medium leads to
	mathematical inconsistencies: there is no single ground truth
	in the system, but rather multiple ground truths.  These
	inconsistencies are not an accident or specific to our
	particular medium.  Rather, they are inevitable in any
	cognitive medium that has both the flexibility of
	paper-and-pencil and the ability to automatically do
	computations and inference.  To resolve this problem, we must
	develop an internal data model for the medium and a user
	interface that lets us reason about these multiple ground
	truths.  We'll identify a set of principles that enable a
	medium to support this kind of <em>semi-concrete
	reasoning</em>.  I believe semi-concrete reasoning will be an
	important part of any concrete, exploratory medium for
	mathematics.
      </p>


      <p>
	<h2>Introducing the singular value decomposition</h2>
      </p>

      <p>
	Before getting to our exploratory medium, it helps to learn a
	little about the singular value decomposition (SVD).  If
	you're not familiar with the SVD, it's a way of breaking a
	matrix up into three simple components.  It's most easily
	understood for a real $2 \times 2$ matrix $M$, where the SVD
	guarantees that it's always possible to break $M$ up into a
	rotation about the origin, followed by a rescaling of the
	co-ordinate axes, followed by a second rotation about the
	origin.  Each of these three components is easy to reason
	about individually, and that often makes it easy to reason
	about the matrix as a whole.  The great thing about the SVD is
	that it guarantees that <em>every</em> $2 \times 2$ matrix can
	be broken up in this way, for suitable choices of rotations
	and rescaling*<span class="marginnote">* Actually, the full
	statement of the SVD is slightly more complex.  I'll explain
	it in a moment.</span>.  It's similar to the way knowing the
	prime factorization of a number can make it easier to reason
	about that number.
      </p>

      
      <p>
        The SVD doesn't just apply to $2 \times 2$ matrices.  For a
        real $n \times n$ matrix $M$, the SVD says such a matrix can
        always be decomposed as*<span class="marginnote">* There are
        versions of the SVD which apply to non-square matrices, to
        infinite matrices and linear operators, and to matrices over
        fields other than the real numbers.  For our purposes, the $n
        \times n$ real case is a good level of generality.  Many of
        the ideas can, in any case, be applied in more general
        contexts. </span>
      </p>

      <p>
	\begin{eqnarray}
	M = U \, {\rm diag}(s_1, s_2, \ldots, s_n) \, V.
	\end{eqnarray}
      </p>

      <p>
	Here, the matrices $U$ and $V$ are real $n \times
	n$ <em>orthogonal</em> matrices.  As you may guess from the
	earlier discussion, orthogonal matrices are generalizations of
	the 2-dimensional rotations.  In particular, they're matrices
	which <em>preserve length</em> in $n$ dimensions, just as
	rotations preserve length in 2 dimensions.  That is, if $U$ is
	an orthogonal matrix and $v$ is any vector, then the length
	$\|U v\|$ is always the same as the length $\|v\|$.  Formally,
	a square matrix $U$ is defined to be orthogonal if $U^T U =
	I$, where $T$ is the transpose operation, and $I$ is the
	identity matrix*<span class="marginnote">* To see how this
	relates to length preservation, observe that $\|v\|^2 = v^T
	v$, i.e., the sum of the squares of the components of $v$.
	Using this observation we have $\|Uv \|^2 = v^T U^T U v = v^T
	v = \|v\|^2$, where we substituted $U^T U = I$ to get the
	second equality.</span>.  And so in the case of the SVD we
	have $U^TU = I$ and $V^T V = I$.
      </p>

      <p>
	The other part of the singular value decomposition $(1)$ was
	the diagonal matrix ${\rm diag}(s_1, s_2, \ldots, s_n)$.  The
	diagonal entries $s_1 \geq s_2 \geq \ldots \geq s_n \geq 0$
	are known as the <em>singular values</em> of the matrix $M$.
	These singular values simply rescale the corresponding
	directions in $n$-dimensional vector space. Putting it all
	together, the SVD says any matrix can be broken up into an
	orthogonal &ldquo;rotation&rdquo;, a rescaling, and another
	orthogonal &ldquo;rotation&rdquo;*<span class="marginnote">* I
	told a small lie in my explanation of the $2 \times 2$ case.
	The $2 \times 2$ orthogonal matrices include not just
	rotations, but also reflections.  As an example, consider the
	matrix $\begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}$, which
	reflects about the $x$ axis.  It's easily verified that this
	is an orthogonal matrix, but it's not a rotation.  In fact,
	you can show that an arbitrary $2 \times 2$ orthogonal matrix
	is either a rotation, or a product of $\begin{bmatrix} 1 & 0
	\\ 0 & -1 \end{bmatrix}$ with a rotation.  An analogous
	statement is true in $n$ dimensions.  In practice, you can
	mostly ignore the reflections, and think of orthogonal
	matrices as rotations in $n$ dimensions.</span>.
      </p>

      <p>
	While we're going to prove the SVD, the proof is not the main
	point of the essay. As such, I will take it for granted that
	you're willing to believe the SVD is interesting.  This means
	we won't get deeply into the applications or meaning of the
	SVD.  But with that said, it's worth knowing that the SVD is a
	widely used tool, for applications ranging
	from <a href="https://en.wikipedia.org/wiki/Latent_semantic_analysis">natural
	language processing</a>
	to <a href="https://en.wikipedia.org/wiki/Schmidt_decomposition">quantum
	computing</a> to
	<a href="https://en.wikipedia.org/wiki/Kabsch_algorithm">comparing
	protein structures</a>.  Indeed, it's one of the most useful
	tools in linear algebra, and, indeed, in all mathematics.
      </p>

      <p>
	<h2>A proof of the SVD for $2 \times 2$ matrices</h2>
      </p>

      <p>
	In this section I explain the proof of the SVD in the case
	when $M$ is a $2 \times 2$ matrix.  This proof contains all
	the essential ideas needed for the general proof, which we'll
	discuss later.
      </p>

      <p>
	Rather than attack the problem head-on, let's start with a
	simpler and more natural problem.  This problem will appear
	unrelated, but as we attempt to solve this problem our
	explorations will lead us to the SVD.
      </p>

      <p>
	The simpler problem is the question of how much a $2 \times 2$
	matrix $M$ <em>stretches</em> space?  To understand what I
	mean by stretching space, consider the matrix
      </p>

      $$M = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}.$$

      <p>
	If we let this matrix act on the vector $(1, 0) \equiv
	\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ the vector becomes
      </p>

      $$M \begin{bmatrix} 1 \\ 0 \end{bmatrix} = \begin{bmatrix} 1 \\
      1 \end{bmatrix} $$

      <p>
	The input vector $(1, 0)$ has length $1$, while the output
	vector $(1, 1)$ has length $\sqrt 2$.  So the matrix stretches
	this particular input vector to become a factor $\sqrt{2}$
	longer.
      </p>

      <p>
	Of course, $(1, 0)$ isn't the only possible input vector.  If
	the input were, say, $(0, 1)$ the output would be $M(0, 1) =
	(1, 0)$, which is the same length as the input.  In that
	direction, $M$ doesn't stretch space at all.
      </p>

      <p>
	The question we'll investigate is this: what is
	the <em>maximal</em> degree of stretching associated to some
	given matrix, $M$?  In other words, if we consider all unit
	vectors $v$, what is the maximal value for the length $\| M
	v\|$?
      </p>

      <p>
	I'm abusing terminology a little here &ndash; $M$ might
	actually shrink unit vectors in some directions, or even in
	every direction.  But the term &ldquo;stretch&rdquo; is
	evocative, so we'll continue using
	it*<span class="marginnote">* Stretching is not a standard
	mathematical term.  Mathematicians often refer to this maximal
	stretching as the matrix norm, or, a little more formally, as
	the matrix norm induced by the Euclidean distance.</span>.
      </p>

      <p>
	We won't solve this problem immediately, but will instead do
	some exploration that helps us understand the problem.  The
	exploration will be illustrated using a rough prototype of a
	cognitive medium for doing linear algebra.  Think of what
	follows as someone doing real, live mathematical work, trying
	to better understand the maximal degree of stretching
	associated to a $2 \times 2$ matrix.  This is a record of
	their explorations. To start the demo, please play the video
	below.  Of course, in a real medium, you'd be able to
	interrupt, do your own exploration, and so on.  But this is
	just a prototype, to explore ideas, and so I haven't built the
	medium out to do that.  Here it is*<span class="marginnote">*
	Original video may be
	downloaded <a href="images/exploration.mp4">here</a>.</span>:
      </p>

      <iframe width="560" height="315" src="https://www.youtube.com/embed/fnUrGAMf-8M?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>

      <!--
      <prototype text="Play" name="proof">
	<init_pointer></init_pointer>
	<run>
	  icon_bar("proof");
	</run>
	<ticker></ticker>
	<icon x="596" y="36" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="100" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="164" src="images/unit_vectors.png" name="unit_vectors"></icon>

	<pause delay="1500"></pause>
	<ticker>We start by setting up an unknown two by two matrix</ticker>
	<pause delay="1000"></pause>

	<select_icon name="matrix"></select_icon>
	<run>
	  var img = image("images/matrix_1.png", 10, 40);
	  img.id = "matrix1";
	  document.getElementById("prototype0").appendChild(img);
	</run>

	<pause delay="2000"></pause>
	<ticker>This creates a 2 by 2 matrix</ticker>

	<pause delay="2000"></pause>
	<ticker>We'll give the matrix a name, <em class="prototype_math">M</em></ticker>

	<pause delay="500"></pause>
	<move_mouse x="25" y="55"></move_mouse>

	<pause delay="250"></pause>
	
	<run>
	  document.getElementById("matrix1").style.display = "none";
	  animate_frames(
	   0, ["images/matrix2.png", "images/matrix3.png",
	       "images/matrix4.png", "images/matrix5.png"], [800, 800, 800, 0], 10, 40);
	</run>
	
	<pause delay="3500"></pause>
	<ticker>Then display a set of axes</ticker>
	<pause delay="1000"></pause>
	
	<select_icon name="axes"></select_icon>

	<run>
          plot_axes("proof")
	</run>

	<pause delay="2000"></pause>
	<ticker>Next, plot all the unit vectors</ticker>
	<pause delay="500"></pause>
	
	<select_icon name="unit_vectors"></select_icon>

	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	</run>

	<pause delay="2000"></pause>
	<ticker>Apply the matrix to the unit vectors</ticker>
	<pause delay="500"></pause>

	<move_mouse x="30" y="60"></move_mouse>
	<pause delay="250"></pause>
	<change_mouse_pointer name="images/matrix_mouse_pointer.png" x="10" y="40"></change_mouse_pointer>
	
	<move_mouse x="190" y="130" interrupt="96">
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.clear();
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_axes("proof");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), "yellow", 6);
	</move_mouse>

	<pause delay="400"></pause>

	<change_mouse_pointer name="images/cursor.png" x="205" y="145"></change_mouse_pointer>

	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.clear();
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_axes("proof");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  plot_image("proof");
	</run>

	<pause delay="500"></pause>

	<ticker>The orange curve shows <em class="prototype_math">Ms</em> for all unit vectors <em class="prototype_math">s</em></ticker>
	
	<pause delay="3000"></pause>

	<ticker>We'll talk about this curve quite a bit, so we'll give it a name</ticker>
	<pause delay="4000"></pause>

	<ticker>We'll call it the <em>image of the unit circle</em> or just the <em>image curve</em></ticker>
	<pause delay="4000"></pause>
	
	  
	<ticker>Pick out the unit
	vector <em class="prototype_math">s</em> which becomes the
	longest</ticker>
	<pause delay="4000"></pause>
	<ticker>We will call <em class="prototype_math">s</em>
	the <em>principal right singular vector</em></ticker>
	<pause delay="5000"></pause>
	<ticker>The reason for the name will become apparent later</ticker>
	<pause delay="4000"></pause>
	<move_mouse x="30" y="60"></move_mouse>
	<run>
	  var img = image("images/prsv_menu_1.png", 35, 62);
	  img.id = "prsv_menu_1";
	  document.getElementById("prototype0").appendChild(img);
	</run>
	<pause delay="300"></pause>
	<move_mouse x="55" y="75" interrupt="20">
	  deleteElement(document.getElementById("prsv_menu_1"));
	  var img2 = image("images/prsv_menu_2.png", 35, 62);
	  img2.id = "prsv_menu_2";
	  document.getElementById("prototype0").appendChild(img2);
	</move_mouse>
	<pause delay="2500"></pause>
	<run>
	  deleteElement(document.getElementById("prsv_menu_2"));
	</run>
	
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="310" y="60"><em class="prototype_math">Ms</em></text>
	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="5000"></pause>

	<ticker>Notice that <em class="prototype_math">Ms</em> is, as expected, the longest vector on the image curve</ticker>
	<pause delay="5000"></pause>
	
	<ticker>Let's look at the tangent to the image curve at <em class="prototype_math">Ms</em></ticker>
	<move_mouse x="315" y="65"></move_mouse>
	<pause delay="300"></pause>
	<run>
	  var img1 = image("images/tangent_vector_menu_1.png", 320, 67);
	  img1.id = "tangent_vector_menu_1";
	  document.getElementById("prototype0").appendChild(img1);
	</run>
	<pause delay="300"></pause>
	<move_mouse x="350" y="75" interrupt="20">
	  deleteElement(document.getElementById("tangent_vector_menu_1"));
	  var img2 = image("images/tangent_vector_menu_2.png", 320, 67);
	  img2.id = "tangent_vector_menu_2";
	  document.getElementById("prototype0").appendChild(img2);
	</move_mouse>
	<pause delay="3000"></pause>
	<run>
	  deleteElement(document.getElementById("tangent_vector_menu_2"));
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	    xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="5000"></pause>
	
	<ticker>Visually, it's plausible the tangent is orthogonal
	  to <em class="prototype_math">Ms</em> (tangent
	  &perp; <em class="prototype_math">Ms</em>)</ticker>
	<pause delay="4000"></pause>

	<ticker>What's more, the tangent <em>isn't</em> &perp; at most
	places on the image curve</ticker>
	<pause delay="6000"></pause>

	<ticker>So the tangent being &perp;
	  at <em class="prototype_math">Ms</em> is a special property
	  of <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>Maybe that's useful for figuring out the maximal stretching</ticker>
	<pause delay="6000"></pause>

	<ticker>Let's make a conjecture:</ticker>
	<pause delay="2000"></pause>
	<text x="15" y="337"><strong>Conj:</strong> The tangent to the
	image curve at <em class="prototype_math">Ms</em> is
	orthogonal to <em class="prototype_math">Ms</em></text>
	<pause delay="7000"></pause>

	<ticker>Let's try to prove the tangent is orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>To do this, suppose the tangent <em>isn't</em>
	orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>We'll show this leads to a contradiction</ticker>
	<pause delay="4000"></pause>

	<ticker>And so conclude that the tangent must have been
	orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>Okay, suppose the tangent has a component in the
	<em class="prototype_math">Ms</em> direction</ticker>
	<pause delay="3500"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function animate_attempt() {
  	    var ctx = document.getElementById("proof").getContext("2d");
	    ctx.clear();
	    plot_axes("proof");
	    icon_bar("proof");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1]];
	    plot_image_partial("proof", Mt_interp, k/50);
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Mt_interp[0]+Ms_vec[0]),
	      ys(Mt_interp[1]+Ms_vec[1]), IMAGE_COLOR, 2);
	    $("#pointer0").css("left", xs(Mt_interp[0]+Ms_vec[0])+"px").css(
	      "top", ys(Mt_interp[1]+Ms_vec[1])+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt);
	    }
	 }
	 animate_attempt();
	</run>
	<init_pointer x="298" y="48"></init_pointer>
	
	<pause delay="5000"></pause>
	
	<ticker>We can see that there's a problem</ticker>
	<pause delay="3000"></pause>
	<ticker>Let's look at the image curve near but not at <em class="prototype_math">Ms</em></ticker>
	<pause delay="4000"></pause>

	<move_mouse x="310" y="88"></move_mouse>
	<kill_pointer></kill_pointer>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function run_along_curve() {
  	    var ctx = document.getElementById("proof").getContext("2d");
	    ctx.clear();
	    plot_axes("proof");
	    icon_bar("proof");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    plot_image_partial("proof", Mt_fake_vec, 1);
	    var position = vector_image_partial(Mt_fake_vec, 1, 0.5*k/50);
	    ctx.arrow(xs(0), ys(0), xs(position[0]), ys(position[1]), IMAGE_COLOR, 1);
	    ctx.beginPath();
	    ctx.arc(xs(position[0]), ys(position[1]), 3, 2*Math.PI, false), 
	    ctx.fillStyle = '#555';
	    ctx.fill();
	    ctx.lineWidth = 0;
	    ctx.stroke();
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(run_along_curve);
	    }
	  }
          run_along_curve();
	</run>
	<pause delay="2000"></pause>
	<ticker>Points on the image curve get further from the origin</ticker>
	<pause delay="4500"></pause>
	<init_pointer x="295" y="71"></init_pointer>
	<pause delay="500"></pause>
	
	<ticker>The reason is that we're moving further out in the
	direction of <em class="prototype_math">Ms</em></ticker>
	<pause delay="6000"></pause>
	
	
	<ticker>This shouldn't have been possible,
	since <em class="prototype_math">Ms</em> was the longest
	vector</ticker>
	<pause delay="5000"></pause>
	
	<ticker>And so our assumption that the tangent is not &perp;
	must have been wrong</ticker>
	<pause delay="5000"></pause>

	<ticker>And so the conjecture is true</ticker>
	<pause delay="4000"></pause>

	<ticker>Of course, we need to fill some steps in to rigorously
	  prove this</ticker>
	<pause delay="5000"></pause>
	
	<ticker>We'll do that shortly</ticker>
	<pause delay="3000"></pause>

	<ticker>But that's the core idea</ticker>
	<pause delay="4000"></pause>
	
      </prototype>
      -->
      
      <p>
	Let's fill in the steps skipped above, to take the proof of
	the conjecture from geometric idea to rigorous proof.  Let $T$
	be the tangent vector at $Ms$.  Recall that we're trying to
	prove that $T$ is orthogonal to $Ms$.  Our strategy is to
	assume $T$ has a component in the direction of $Ms$, that is,
	$Ms \cdot T > 0$, and to try to deduce a
	contradiction*<span class="marginnote">* It might also be that
	$Ms \cdot T < 0$, in which case we would replace $T$ by $-T$,
	i.e., use the tangent in the other direction along the
	curve.</span>.  Because $T$ is the tangent to the image curve,
	vectors on the image curve near $Ms$ can be written as
	$Ms+\Delta T + O(\Delta^2)$ for some small parameter $\Delta$.
	The squared length of such a vector is:
      </p>

      <p>
	$$\|Ms+\Delta T + O(\Delta^2)\|^2 = \|Ms\|^2+ 2 \Delta \, Ms
	\cdot T + O(\Delta^2)$$
      </p>
      
      <p>
	But $Ms \cdot T > 0$, so for small $\Delta$ we have
	$\|Ms+\Delta T + O(\Delta^2)\|^2 > \|Ms\|^2$, i.e., moving
	along the image curve does, indeed, give us a vector longer
	than $Ms$.  That's a rigorous proof of what we wanted to show.
      </p>


      <p>
	We learned from the above explorations that the tangent to the
	image curve at $Ms$ is orthogonal to $Ms$.  We can make this
	observation more explicit by expressing the tangent $T$ in
	terms of existing quantities like $M$ and $s$.  To do this,
	recall that the image curve arose by applying $M$ to the unit
	circle.  It should be plausible that the tangent to the image
	curve at $Ms$ is just $Mt$ where $t$ is the tangent to the
	unit circle at $s$.  This can be proved with a little
	calculus*<span class="marginnote">* I won't go through the
	details, though it's a good exercise if it's not immediately
	obvious.  Incidentally, this is standard calculus, and could
	be something the medium automatically &ldquo;knows&rdquo;, and
	suggests to the user through the interface.</span>.  It's
	easiest to see the situation through an illustration:
      </p>

      <img src="images/tangent_definition.png"/>

      <!--
      <prototype static="true" name="tangents">
	<run>
  	  var ctx = document.getElementById("tangents").getContext("2d");
          plot_axes("tangents");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(s_vec[0]), ys(s_vec[1]),
	    xs(s_vec[0]+t_vec[0]), ys(s_vec[1]+t_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  plot_image("tangents");
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	    xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="315" y="70"><em class="prototype_math">Ms</em></text>
	<text x="303" y="108"><em class="prototype_math">t</em></text>
	<text x="235" y="60"><em class="prototype_math">Mt</em></text>

      </prototype>
      -->
      
      <p>
	We can make things even more explicit, noting that the tangent
	$t$ is orthogonal to $s$, since it's the tangent to a circle.
	And so the previous observation that the tangent to the image
	curve at $Ms$ is orthogonal to $Ms$ can be rewritten as:
      </p>

      <p>
	<strong>Lemma:</strong> <em>Let $s$ be the principal right
	singular vector of $M$, and let $t$ be orthonormal to $s$.
	Then $Ms$ is orthogonal to $Mt$.</em>
      </p>

      <p>
	The lemma tells us that the principal right singular vector
	$s$ is a very special vector.  For orthonormal vectors $s$ and
	$t$ it usually is <em>not</em> the case that $Ms$ is
	orthogonal to $Mt$.  What we learn from the lemma is that this
	is, however, true for the principal right singular vector.
	That's a powerful thing to know.
      </p>

      <p>
	In fact, it actually lets us prove the SVD for $2 \times 2$
	matrices.  Let's use the lemma to explicitly construct each of
	the rotation-rescaling-rotation steps, in terms of $s, t, Ms$
	and $Mt$.  To see how this works, please play the video below.
	Note that I've moved $t$ and $Mt$ to the origin, emphasizing
	that $t$ is orthogonal to $s$, and $Mt$ is orthogonal to $Ms$.
      </p>

      <video width="654" controls>
	<source src="images/svd.mp4" type="video/mp4">
      </video>

      <!--
      <prototype text="Play" name="see_svd">

	<comment>Initial setup</comment>
	<ticker></ticker>
	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  plot_axes("see_svd");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(t_vec[0]), ys(t_vec[1]), UNIT_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="219" y="118"><em class="prototype_math">t</em></text>

	<ticker>Let's consider <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em></ticker>
	<pause delay="3000"></pause>

	<ticker>Goal:
	rotate-rescale-rotate <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em> to get
	to <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em></ticker>
	<pause delay="5000"></pause>
	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="300" y="60"><em class="prototype_math">Ms</em></text>
	<text x="200" y="176"><em class="prototype_math">Mt</em></text>
	<pause delay="5000"></pause>

	<ticker>To explain the operations, we'll focus
	on <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em>
	</ticker>
	<pause delay="4500"></pause>

	<ticker>We'll ghost <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em> out</ticker>
	<pause delay="4000"></pause>

	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  ctx.clear();
	  plot_axes("see_svd");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(t_vec[0]), ys(t_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.5);
	  ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.5);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="219" y="118"><em class="prototype_math">t</em></text>
	<text x="300" y="60"><em class="prototype_math ghost">Ms</em></text>
	<text x="200" y="176"><em class="prototype_math ghost">Mt</em></text>
	<pause delay="3000"></pause>

	<ticker>But leave slightly visible as reminder of goals
	  for <em class="prototype_math">s</em>
	  and <em class="prototype_math">t</em></ticker>
	<pause delay="5000"></pause>
	
	<comment>First rotation</comment>
	<ticker>We start by rotating <em class="prototype_math">s</em>
	and
	  <em class="prototype_math">t</em> to the co-ordinate
	  axes</ticker>
	<pause delay="4000"></pause>
	<comment>A crude hack to hide the labels</comment>
	<text x="345" y="148"><em class="prototype_math" style="color: #eee">s</em></text>
	<text x="219" y="118"><em class="prototype_math" style="color: #eee">t</em></text>
	<pause delay="1000"></pause>
	<run>
	  var theta = 0.0;
	  function plot_rotation_1() {
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var rot = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];
	    var s_rot_vec = m_times_v(rot, s_vec);
	    var t_rot_vec = m_times_v(rot, t_vec);
	    theta -= 0.003;
	    ctx.arrow(xs(0), ys(0), xs(s_rot_vec[0]), ys(s_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(t_rot_vec[0]), ys(t_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.7);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.7);
            if (theta > -phi) {window.requestAnimationFrame(plot_rotation_1)};
          }
	  plot_rotation_1();
	</run>
	<pause delay="4500"></pause>

	<ticker>We can do this
	because <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em> are orthonormal</ticker>
	<pause delay="4000"></pause>

	<ticker>Rescale axes by factors $\|Ms\|$ and $\|Mt\|$</ticker>
	<pause delay="2000"></pause>
	<run>
          var Ms_length = length_vec(Ms_vec);
	  var Mt_length = length_vec(Mt_vec);

	  function interpolate(k, len) {
	    return (k/100.0) * len + (1-k/100.0) * 1.0;
	  }
	  
	  function rescale(k) {
	    // k will vary from 0 to 100
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var e1_rescale = [interpolate(k, Ms_length), 0];
	    var e2_rescale = [0, interpolate(k, Mt_length)];
	    ctx.arrow(xs(0), ys(0), xs(e1_rescale[0]), ys(e1_rescale[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(e2_rescale[0]), ys(e2_rescale[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.7);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.7);
            if (k < 100) {
              window.requestAnimationFrame(function() {rescale(k+1)})
		    };
          }
	  rescale(0);
	</run>
	<pause delay="4500"></pause>

	<ticker>This leaves the rescaled vectors the &ldquo;right&rdquo; lengths, $\|Ms\|$ and $\|Mt\|$</ticker>
	<pause delay="5000"></pause>
	
	<ticker>Rotate rescaled axes
	to <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em></ticker>
	<run>
          var Ms_length = length_vec(Ms_vec);
	  var Mt_length = length_vec(Mt_vec);

	  var theta = 0.0;
	  function plot_rotation_2() {
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var rot = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];
	    var e1_rescale = [Ms_length, 0];
	    var e2_rescale = [0, Mt_length];
	    var e1_rot_vec = m_times_v(rot, e1_rescale);
	    var e2_rot_vec = m_times_v(rot, e2_rescale);
	    theta += 0.005;
	    ctx.arrow(xs(0), ys(0), xs(e1_rot_vec[0]), ys(e1_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(e2_rot_vec[0]), ys(e2_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.5);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.5);
            if (theta < psi) {window.requestAnimationFrame(plot_rotation_2)};
          }
	  plot_rotation_2();

	</run>
	<pause delay="6000"></pause>
	
	<ticker>We can do this
	because <em class="prototype_math">Ms</em>
	&#8869; <em class="prototype_math">Mt</em></ticker>
	<pause delay="5000"></pause>

	<ticker>The net effect is to
	take <em class="prototype_math">s</em>
	to <em class="prototype_math">Ms</em> and
	  <em class="prototype_math">t</em>
	  to <em class="prototype_math">Mt</em>, as desired</ticker>
	<pause delay="5000"></pause>

	<ticker>It may help to rewatch this to grok all the
	operations</ticker>
	<pause delay="5000"></pause>
	
      </prototype>
      -->
      
      <p>
        To recap, we rotate the principal right singular vector $s$ to
        the first co-ordinate axis.  This rotation automatically
        rotates the vector $t$ (which is orthonormal to $s$) to the
        second co-ordinate axis.  We then rescale the first
        co-ordinate axis by a factor $\|Ms\|$, and the second
        co-ordinate axis by a factor $\|Mt\|$.  And finally we rotate
        the rescaled vectors to $Ms$ and $Mt$.  This last step makes
        crucial use of the lemma, since it's only possible because
        $Ms$ and $Mt$ are orthogonal*<span class="marginnote">* A
        point I glossed over in the visual proof is that it may be
        necessary to reflect one of the axes.  If that's the case the
        reflection can be absorbed into the rotation, and it'll still
        be an orthogonal matrix. This is why the SVD is stated in
        terms of orthogonal matrices, rather than rotations.</span>.
      </p>

      <p>
	By construction, this rotation-rescaling-rotation combination
	takes $s$ to $Ms$ and $t$ to $Mt$.  In fact, it follows that
	the rotation-rescaling-rotation combination must do the same
	as $M$ for <em>all</em> possible inputs.  The reason is that
	$s$ and $t$ form a basis for the vector space, and since both
	$M$ and the rotation-rescaling-rotation act linearly, they
	must therefore have the same action on all vectors.  Thus, $M$
	is equal to the rotation-rescaling-rotation operation.  And so
	we've proved the singular value decomposition for $2 \times 2$
	matrices.
      </p>

      <p>
	Well, that's pretty nice!  We started out with a question
	about how much a matrix stretches space, and the singular
	value decomposition more or less dropped out of our
	exploration.  Indeed, if you carefully review the key ideas in
	the proof, the SVD is an almost obvious consequence of two
	simple and easily-visualized geometric ideas: (1) $Ms$ must be
	orthogonal to $Mt$, otherwise it would be possible to go
	&ldquo;further out&rdquo; along the image curve; and (2) the
	rotation-rescaling-rotation sequence just visualized.  What's
	more, while our proof of the SVD was in $2$ dimensions, the
	proof is easily extended to $n$ dimensions.  That
	generalization is incidental to the main point of this essay,
	so I've sketched it out in <a href="#appA">Appendix A</a>.
      </p>

      <p>
	An interesting aspect of the discussion so far is that we
	actually <em>haven't</em> solved our original problem: to
	figure out the maximal degree of stretching.  This mirrors
	what often happens in real mathematical work &ndash; you may
	not solve the problem you originally intended to solve, but
	you learn something interesting anyway!  In fact, it's
	possible to use the SVD to solve our original problem, finding
	the maximal stretching.  Again, this is incidental to the main
	point of this essay, and so I describe how to do it
	in <a href="#appB">Appendix B</a>.
      </p>

      <p>
	<h2>Semi-concrete reasoning</h2>
      </p>

      <p>
	I glossed over a very interesting moment in our proof of the
	SVD.  It's the point where we ask what happens if the tangent
	vector has a component in the direction of $Ms$.  Let me
	remind you what happens.  It takes just a few
	seconds*<span class="marginnote">* Original video may be
	downloaded <a href="images/exploration_extract.mp4">here</a>.</span>:
      </p>

      <iframe width="656" height="369" src="https://www.youtube.com/embed/_N0qrY5vhA0" frameborder="0" allowfullscreen></iframe>

      <p>
	This appears simple and natural.  It's the kind of thing a
	mathematician working with paper-and-pencil does almost
	without thinking.  But in a computer-based medium, something
	sophisticated must be going on under the hood.  To understand
	why, let's think about how the medium would model the actions
	shown.  A natural approach is to start with a matrix $M$ which
	has some generic values filled in.  In fact, the values for
	$s, t, Ms$ and so on shown above are produced by the following
	matrix $M$:
      </p>

      <p>
      $$M = \begin{bmatrix} 0.70 & -0.28 \\ 1.27 & 0.86 \end{bmatrix} $$
      </p>

      <p>
	So, for example, the image curve is computed by applying this
	particular $M$ to the points making up the unit circle.  And
	the principal right singular vector $s$ is computed from this
	$M$.  And so on, for all the properties computed by the
	medium.
      </p>

      <p>
	In using this specific $M$ we're following a time-honored
	mathematical tradition: in order to reason about some general
	class of objects &ndash; in this case, all the $2 \times 2$
	matrices &ndash; our medium has picked out one particular $2
	\times 2$ matrix, and is using it as a generic example.  The
	benefit of doing this is that it lets the medium do all
	computations explicitly, so we can reason from concrete,
	easily-understood and visualized examples.  So, for instance,
	using a concrete example makes it easy to notice that the
	tangent to the image curve at $Ms$ is orthogonal to $Ms$, when
	$s$ is the principal right singular vector.  Of course, the
	medium only shows this for this specific matrix $M$.  But the
	fact that the example matrix $M$ is generic makes it plausible
	that this phenomenon holds for any $2 \times 2$ matrix.
	Indeed, it would be easy to check for other choices of $M$,
	though I didn't explicitly show that happening.  This practice
	of using concrete-but-generic examples to gain insight has
	been common all through history, but is made especially easy
	with digital computers*<span class="marginnote">* There's an
	art to picking out generic examples that don't mislead.
	That's not a problem I'm going to discuss in detail, but it's
	a fascinating subject.  To develop a good concrete medium for
	doing mathematics, I suspect it's a subject which would need
	to be investigated in great depth.  Incidentally, in the
	essay <a href="http://worrydream.com/LadderOfAbstraction/">Up
	and Down the Ladder of Abstraction</a>, Bret Victor has
	described powerful techniques which sometimes make it possible
	to eschew generic examples, and instead work with concrete
	visualizations representing the space of all
	examples. </span>.
      </p> 

      <p>
	Now, what happens when we drag the tangent away from its
	actual value to a value not orthogonal to $Ms$, as shown in
	the video just above?
      </p>

      <p>
	Before the change the medium was keeping track of the
	following mathematical objects:
      </p>
      
      <p>
	<pre>
M:  a 2 by 2 matrix, with entries 0.70, -0.28, ...
The unit circle
The image of the unit circle under M
s:  the principal right singular vector, with entries 0.89, 0.46
Ms: the result of applying M to s, with entries 0.49, 1.52
The tangent to the image curve at Ms, with entries -0.57, 0.18
	</pre>
      </p>

      <p>
	What happens to the internal state of the medium when we
	change the tangent?  Of course, our internal representation of
	the tangent must change.  But there are challenges in updating
	our description of the other objects.  Most glaringly, no
	matrix $M$ exists which has the desired values for $Ms$ and
	the changed tangent.
      </p>

      <p>
	One natural response is to declare the value of $M$ to
	be <code>undefined</code>.  If we do that, then it's also
	natural to declare $s$, the principal right singular vector of
	$M$, as <code>undefined</code>.  Ditto the image curve.  Our
	mathematical objects are all vanishing!  We started with the
	idea of computing everything from underlying concrete objects.
	That's difficult to do when our objects no longer exist.
      </p>

      <p>
	The problem is that we're trying to describe an impossible
	world.  There is no consistent set of mathematical objects
	that satisfies all the constraints we've imposed in our
	system.  And yet despite this inconsistency, we'd like to
	continue reasoning.  After all, a mathematician working with
	pencil-and-paper has no trouble continuing at this point.  The
	reason this is possible is that a static medium like
	paper-and-pencil does no computation or constraint-checking.
	The medium doesn't tell us it's not possible to make changes
	to a sketch like
      </p>

      <img src="images/paper1.jpg"/>

      <p>
	erasing and modifying the tangent and image curve so the
	sketch becomes
      </p>


      <img src="images/paper2.jpg"/>

      <p>
	This is despite the fact that there is no matrix $M$ having
	the depicted values.
      </p>

      <p>
	This lack of constraint checking is both a feature and a bug.
	Because paper-and-pencil doesn't enforce this kind of
	constraint checking, it relies on the mathematician to do the
	constraint checking in their head in a principled way.  That's
	a substantial cognitive burden.  But it also gives the
	mathematician a lot of freedom to carry out counterfactual
	reasoning, like we did in the last section.
      </p>

      <p>
	One possible response is to puritanically say &ldquo;Oh, well,
	we shouldn't do this kind of reasoning in our medium&rdquo;.
	While that would be convenient, it'd be burying our head in
	the sand.  Real mathematicians engage in this kind of
	counterfactual reasoning all the time.  They're happy to
	imagine impossible worlds <em>en passant</em>, and to make
	progress by asking &ldquo;What would happen if this world
	actually existed?&rdquo;
      </p>


      <p>
	Systems for doing mathematics by computer, such as Matlab and
	Mathematica, are often terrific at doing computations with
	concrete objects.  They can verify in a flash that $Ms$ is
	orthogonal to $Mt$ for any specific choice of matrix $M$.  But
	they don't always make it easy to do counterfactual reasoning.
	There's no easy way of asking Matlab to suppose that $Ms$ is
	not orthogonal to $Mt$.  And this actually makes it harder to
	prove that $Ms$ is always orthogonal to $Mt$, for any $2
	\times 2$ matrix $M$.  If we make counterfactual reasoning
	difficult, then we greatly weaken our medium of discovery.
      </p>

      <p>
	What we'd ideally like is a medium supporting what we will
	call <em>semi-concrete reasoning</em>.  It would
	simultaneously provide: (1) the ability to compute concretely,
	to apply constraints, and to make inferences, i.e., all the
	benefits we expect a digital computer to apply (and which made
	it so easy to notice that $Ms$ is orthogonal to the tangent in
	the first place); and (2) the benefits of paper-and-pencil,
	notably the flexibility to explore and make inferences about
	impossible worlds.  As we've seen, there is tension between
	these two requirements.  Yet it is highly desirable that both
	be satisfied simultaneously if we are to build a powerful
	exploratory medium for doing mathematics.  That is true not
	just in the medium I have described, but in any exploratory
	medium.
      </p>

      <p>
	In the next section I sketch an approach to building a system
	for semi-concrete reasoning.  We shall see that this is a
	challenging problem, with open-ended components involving the
	psychology of the user, and what constitutes
	&ldquo;natural&rdquo; modes of mathematical inference.  We
	won't completely solve the problem.  But we will at least
	better understand some of the principles to be followed in any
	system for semi-concrete reasoning.
      </p>

      <p>
	Before moving to those principles, let me briefly mention some
	connections between semi-concrete reasoning and existing
	systems.  One connection is to constraint-based media.
	Pioneered by the graphics medium Sketchpad, such media enable
	users to build systems by declaring constraints on those
	systems. The idea is that the medium finds a solution
	(possibly approximate) satisfying the constraints, often by
	minimizing some sort of cost
	function*<span class="marginnote">* There is a large
	literature on this.  A good starting point for comparison to
	the current work is the work
	on <a href="refs/Borning1992a.pdf">Constraint Hierarchies</a>
	by Alan Borning, Bjorn Freeman-Benson, and Molly Wilson
	(1992).</span>.  This idea has found application in many
	areas, including graphics, computer-aided design, simulation,
	user interface design, and programming languages.</p>

      <p>
	Our medium differs from such systems in that it deliberately
	maintains, and attempts to make reasoned inferences from, a
	constraint violation.  There's no cost to be minimized, and
	we're not trying to find a solution, approximate or otherwise.
	Rather, the goal is to understand the implications of the
	constraint violation in a step-by-step way, a way where the
	inferences being made are clearly legible to the user.
      </p>

      <p>
	Another connection is to proof assistants and systems for
	automated reasoning, such as Coq and Agda.  Such systems do
	enable proofs by contradiction and other forms of
	counterfactual reasoning.  However, the aim of such systems is
	different to what I'm describing.  They're typically aimed
	toward helping human users develop formal proofs, rather than
	presenting a user interface to enable informal, concrete,
	exploratory reasoning, and thus have very different interface
	goals.
      </p>
      


      <h2>
	Principles of semi-concrete reasoning
      </h2>

      <p>
	In our earlier discussion, we implicitly assumed our medium
	has an internal data model that represents mathematical
	reality.  In particular, having updated the value for the
	tangent, we assumed it was the job of the medium to find a
	corresponding consistent value for $M$ and for other
	quantities in the problem.
      </p>

      <p>
	It's possible to proceed in a different fashion.  Instead of
	using our medium's data model to represent mathematical
	reality, we can instead <em>use the medium's data model to
	represent the user's current state of mathematical
	knowledge</em>.  This makes sense, since in an exploratory
	medium we are not trying to describe what is true &ndash; by
	assumption, we don't know that, and are trying to figure it
	out &ndash; but rather what the user currently knows, and how
	to best support further inference.
      </p>

      <p>
	Having adopted this point of view, user interface operations
	correspond to changes in the user's state of mathematical
	knowledge, and thus also make changes in the medium's model of
	that state.  There is no problem with inconsistency, because
	the medium's job is only to model the user's current state of
	knowledge, and that state of knowledge may well be
	inconsistent.  In a sense, we're actually asking the computer
	to do less, at least in some ways, by ignoring constraints.
	And that makes for a more powerful medium.
      </p>

      <p>
	Having adopted this point of view, the question is how the
	medium can best support the user's mathematical exploration
	and further inference.  The simplest approach is to allow the
	user to manually edit the mathematical world, with little
	assistance from the computer in doing inference:
      </p>

      <video width="654" controls>
	<source src="images/manual.mp4" type="video/mp4">
      </video>

      <!--
      <prototype text="Play" name="simple_edit">
	<init_pointer></init_pointer>
	<ticker></ticker>
	<icon x="596" y="30" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="94" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="158" src="images/unit_vectors.png" name="unit_vectors"></icon>
	<icon x="596" y="222" src="images/prsv.png" name="prsv"></icon>
	<icon x="596" y="286" src="images/orthogonal_icon.png" name="orthogonal"></icon>

	<run>
	  var ctx = document.getElementById("simple_edit").getContext("2d");
          plot_axes("simple_edit")
 	  icon_bar("simple_edit");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_image("simple_edit");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	  xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="310" y="65"><em class="prototype_math">Ms</em></text>
	<text x="15" y="337"><strong>Conj:</strong> The tangent
	at <em class="prototype_math">Ms</em> is $\perp$ to
	  <em class="prototype_math">Ms</em></text>

	<ticker>Let's click and drag the tangent vector</ticker>
	<pause delay="2000"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function animate_attempt() {
  	    var ctx = document.getElementById("simple_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("simple_edit");
	    plot_axes("simple_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    plot_image("simple_edit");
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Mt_interp[0]), ys(Mt_interp[1]), IMAGE_COLOR, 2);
	    $("#pointer3").css("left", xs(Mt_interp[0])+"px").css("top", ys(Mt_interp[1])+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt);
	    }
	  }
	  animate_attempt();
	</run>
	<init_pointer x="298" y="48"></init_pointer>
	
	<pause delay="2000"></pause>
	<ticker>Then select and delete the image curve</ticker>
	<pause delay="2000"></pause>
	<move_mouse x="283" y="96" interrupt="95">
	  plot_image("simple_edit", 6, "yellow");
	</move_mouse>
	<pause delay="1000"></pause>
	<run>
  	    var ctx = document.getElementById("simple_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("simple_edit");
	    plot_axes("simple_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Ms_vec[0]+Mt_fake_vec[0]),
	      ys(Ms_vec[1]+Mt_fake_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="500"></pause>
	<ticker>Then sketch in the modified image curve</ticker>
	<pause delay="500"></pause>
	<move_mouse x="295" y="71"></move_mouse>
	<pause delay="500"></pause>
	<comment>
	  Note, incidentally, the ugliness of #pointer3 below.  This
	  should really be fixed, and may cause unexpected bugs.
	</comment>
	<run>
	  var ctx = document.getElementById("simple_edit").getContext("2d");
	  var theta = 0.6;
	  var start = vector_image_partial(Mt_fake_vec, 1, theta);
	  var next;
	  function nextArcStep() {
	    theta += -0.01;
	    next = vector_image_partial(Mt_fake_vec, 1, theta);
	  $("#pointer3").css("left", xs(next[0])+"px").css("top", ys(next[1])+"px");
	    ctx.line(xs(start[0]), ys(start[1]), xs(next[0]), ys(next[1]), IMAGE_COLOR);
	    if (theta > -0.6) {
	      start = next;
	      requestAnimationFrame(nextArcStep)
	    }
	  }
	  nextArcStep();
	</run>
	<pause delay="3000"></pause>
      </prototype>
      -->
      
      <p>
	This sequence of operations corresponds roughly to the
	operations performed by a human mathematician with
	paper-and-pencil.  The internal state of the medium after
	these operations would be:
      </p>

      <p>
	<pre>
M:  a 2 by 2 matrix, with entries 0.70, -0.28, ...
The unit circle
The edited image curve
s:  the principal right singular vector, with entries 0.89, 0.46
Ms: the result of applying M to s, with entries 0.49, 1.52
The edited tangent to the image curve at Ms, with entries -0.15, 0.5
	</pre>
      </p>

      <p>
	This is not a consistent mathematical world.  It doesn't need
	to be, since the purpose of our medium's data model is no
	longer to represent a consistent mathematical world, but to
	represent the user's current state of mathematical knowledge,
	and to support further inference.
      </p>

      <p>
	Of course, it's disappointing to require the user to make all
	inferences manually, as they would with paper-and-pencil.
	Ideally, an exploratory medium would help the user make
	inferences, give the user control over how these inferences
	are made, and make it easy for the user to understand and
	track the chain of reasoning.  To appreciate the importance of
	these principles, consider the following medium, which behaves
	differently again when we modify the tangent:
      </p>

      <video width="656" controls>
	<source src="images/multistage.mp4" type="video/mp4">
      </video>

      <!--
      <prototype text="Play" name="illegible_edit">
	<init_pointer></init_pointer>
	<ticker></ticker>
	<icon x="596" y="30" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="94" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="158" src="images/unit_vectors.png" name="unit_vectors"></icon>
	<icon x="596" y="222" src="images/prsv.png" name="prsv"></icon>
	<icon x="596" y="286" src="images/orthogonal_icon.png" name="orthogonal"></icon>

	<run>
	  var ctx = document.getElementById("illegible_edit").getContext("2d");
          plot_axes("illegible_edit")
 	  icon_bar("illegible_edit");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_image("illegible_edit");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	  xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="346" y="150" id="s_swinging"><em class="prototype_math">s</em></text>
	<text x="310" y="65" id="Ms_swinging"><em class="prototype_math">Ms</em></text>

	<ticker>Let's try clicking and dragging the tangent vector again</ticker>
	<pause delay="3000"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<comment>
	  Let me explain the mathematics here, so this is
	  understandable later.

	  We'll move the mouse pointer exactly as before, defining a
	  vector which we'll call interp.  In previous widgets this
	  was called Mt_interp, but we rename since it can't really be
	  understood in terms of an interpolated (and displaced) Mt.

	  What we want is to find a unit vector sp (for s prime) such
	  that:

	  interp - M sp is tangent to M sp on the image curve

	  For this to be the case, we must have

	  interp - M sp proportional to M sp_perp,

	  where sp_perp is the tangent to sp on the unit circle.  We
	  can rewrite this as:

	  interp - M sp = c M sp_perp

	  for some constant c.  Multiplying by M^{-1} and taking
	  inner products we have:

	  M^{-1} interp . sp = 1

	  M^{-1} interp . sp_perp = c

	  And so 1+c^2 = ||M^{-1} interp||^2

	  We can solve for c:

	  c = pm sqrt(||M^{-1} interp||^2-1)

	  Thinking about the geometry of our situation, it should be
	  +.  Of course, in general we'd need to do a (rather
	  tedious!) case analysis.
	  
	  c = sqrt(||M^{-1} interp||^2-1)

	  Our earlier equation can also be written:

	  M^{-1} interp = (I+c F) sp

	  where F = [[0, -1], [1, 0]].

	  We can then use this to solve for sp:

	  c = sqrt{||M^{-1} interp||^2-1}

	  sp = (I+c F)^{-1} M^{-1} interp

	  These final two equations let us figure out a suitable value
	  for sp, and then for M sp.

	  There's a lot to do here.  But there's nothing difficult!
	</comment>
	<comment>
	  Note, incidentally, the ugliness of #pointer4 here.  This
	  should really be fixed, and may cause unexpected bugs.
	</comment>
	<run>
	  var k = 0;
	  function animate_attempt_2() {
  	    var ctx = document.getElementById("illegible_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("illegible_edit");
	    plot_axes("illegible_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    plot_image("illegible_edit");
	    var interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	      (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    var inverse_interp = m_times_v(matrix_inverse(M), interp);
	    var c = Math.sqrt(Math.pow(length(inverse_interp), 2)-1);
	    var temp = [[1, -c], [c, 1]];
	    var sp = m_times_v(matrix_inverse(temp), inverse_interp);
	    ctx.arrow(xs(0), ys(0), xs(sp[0]), ys(sp[1]), UNIT_COLOR, 2);
	    var M_sp = m_times_v(M, sp);
	    ctx.arrow(xs(0), ys(0), xs(M_sp[0]), ys(M_sp[1]), IMAGE_COLOR, 2);
	    ctx.arrow(xs(M_sp[0]), ys(M_sp[1]), xs(interp[0]), ys(interp[1]), IMAGE_COLOR, 2);
	    $("#pointer4").css("left", xs(interp[0])+"px").css("top", ys(interp[1])+"px");
	    $("#s_swinging").css("left", (xs(sp[0])+5)+"px").css("top", (ys(sp[1])-23)+"px");
	    $("#Ms_swinging").css("left", (xs(M_sp[0]))+"px").css("top", (ys(M_sp[1])-23)+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt_2);
	    }
	  }
	  animate_attempt_2();
	</run>
	<pause delay="3000"></pause>
      </prototype>
      -->
      
      <p>
	In this medium, as we move the end of the tangent vector, the
	medium finds a new corresponding base point $Ms$ on the image
	curve.  It chooses the new base point so the tangent vector
	is, indeed, a genuine tangent to the image curve (which is
	presumed to be fixed).  At the same time, the medium also
	recomputes the value of $s$, by multiplying the new value for
	$Ms$ by $M^{-1}$.
      </p>
      
      <p>
	Now, in some proofs these may be exactly the desired
	inferential steps.  But upon consideration, this example
	illustrates some genuine design challenges.  In particular, in
	general we'd like to use our medium to reason about a large
	number of mathematical objects.  There is potentially an
	exponentially large number of ways changing one object can
	cause inferred changes in others.  In order for the user to
	understand what is going on, the way inferred changes
	propagate needs to clearly communicated.  In particular, the
	medium must be designed so the user can easily select from
	amongst the many possible chains of inference.
      </p>

      <p>
	In paper-and-pencil mathematics, how we do inference depends
	upon what relationships we know between objects in the system.
	In this case, we know of just a single direct relationship
	between the tangent vector and other objects: the tangent is a
	function of the base point and the image
	curve*<span class="marginnote">* Note that later in the proof
	we learn that the tangent is equal to $Mt$.  That's a second
	important relationship.  However, at the time we're discussing
	that relationship is not yet known to the user, and so isn't
	part of the medium's model of the user's knowledge.</span>:
      </p>

	<img src="images/input_output.png"/>

      <p>
	If we're using paper-and-pencil, we must use this relationship
	to deduce the implications of changing the tangent.  The
	reason is that it's the only relevant thing we know.
	Effectively, we're inverting the relationship:
      </p>

      <img src="images/input_output_inverted.png">

      <p>
	In this particular case, we want the base vector $Ms$ to
	remain unchanged, by assumption.  Given that, we can infer
	what the image curve &ldquo;must have been&rdquo;, given the
	modified value for the tangent.  Of course, the modified image
	curve is not uniquely determined, and so with paper-and-pencil
	we sketch an illustrative curve segment.  That illustrative
	curve segment is <em>not</em> supposed to literally be the
	implied curve segment; rather, it is a curve segment with
	approximately the right shape, and where the base point and
	tangent are exactly correct.
      </p>
      
      <p>
	The paper-and-pencil reasoning is strikingly different to the
	medium last shown, where changing the tangent vector caused an
	immediate change to $s$.  With paper-and-pencil any such
	inference would have required a two-step reasoning process:
	first, figure out what changing the tangent means for $Ms$,
	and then figure out what that change to $Ms$ means for $s$.
      </p>

      <p>
	We could adopt a similar single-step inference approach to our
	exploratory medium.  In such a medium, for every interface
	operation <em>generating</em> a new relationship between
	objects, there would be a corresponding interface operation
	enabling us to infer how changes in any one of those objects
	affects the other objects.  In the specific case we've been
	considering, this means the task of the medium is to present
	the user a way of selecting from amongst the space of base
	vectors and segments of image
	curves*<span class="marginnote">* A point I've glossed over is
	how the medium knows what shape to use for the curve segment.
	One possible answer is to interpolate based on the original
	curve and the modified tangent. This is the strategy I used in
	the prototype, and it seems to work reasonably well.</span>.
      </p>

      <img src="images/input_output_inverted.png">

      <p>
	With paper-and-pencil, this inversion needs to be performed
	mechanically.  In an exploratory medium, the medium can guide
	us in doing the inversion.  Of course, in this instance the
	inference isn't especially hard, so this is only a small win,
	but it nonetheless helps free the user to concentrate on
	higher-level reasoning.
      </p>

      <p>
	Using the medium to support only a single stage of inference
	has several benefits.  It naturally makes the chain of
	inference legible, since it mirrors the way we do inference
	with paper-and-pencil, every step made explicit, while
	nonetheless reducing tedious computational work, and helping
	the user understand what inferences are possible.  It's also
	natural psychologically, since the user is already thinking in
	terms of these relationships, having defined the objects this
	way.  Finally, and perhaps most importantly, it limits the
	scope of the interface design problem, since we need not
	design separate interfaces for the unlimited(!)  number of
	possible inferences.  Rather, for every interface operation
	generating a mathematical object, we need to design a
	corresponding interface to propagate changes.  That's a
	challenging but finite design problem.  Indeed, in the worst
	case, a &ldquo;completely manual&rdquo; interface like that
	presented earlier may in general be used.
      </p>

      <p>
        With that said, one could imagine media which perform multiple
        stages of inference in a single step, such as our medium
        modifying $s$ in response to changes in the tangent.
        Designing such a medium would be much more challenging, since
        potentially many more relationships are involved (meaning more
        interfaces need to be exposed to the user), and it is also
        substantially harder to make the chain of reasoning legible to
        the user.
      </p>

      <p>
	Even with the simplification of doing single-step inference,
	there are still many challenging design problems to be solved.
	Most obviously, we've left open the problem of designing
	interfaces to support these single stages of inference. In
	general, solving this interface design problem is an
	open-ended empirical and psychological question.  It's an
	empirical question insofar as different modes of inference may
	be useful in different mathematical proofs.  And it is a
	psychological question, insofar as different interfaces may be
	more or less natural for the user.  Every kind of relationship
	possible in the medium will require its own interface, and
	thus present a new design challenge.  The simplest way to meet
	that challenge is to use a default-to-manual-editing strategy,
	mirroring paper-and-pencil.  But by providing additional
	inference options we can support more powerful reasoning, and
	strictly surpass paper-and-pencil.
      </p>

      <p>
	A second design problem is the profusion of possible ways in
	which inference may occur.  Later in the proof we connect the
	tangent not just to $Ms$ and the image curve, but also to
	$Mt$.  At that point the user would be aware of two separate
	direct relationships involving the tangent vector:
      </p>

      <img src="images/tangent_all_relationships.png">

      <p>
	The medium would then need to allow the user to make
	inferences about how changes to the tangent
	changed <em>either</em> $Mt$ <em>or</em> $Ms$ and the image
	curve.  In general, the medium needs to allow the user to make
	choices between <em>multiple types of inference</em> possible
	at any given stage.  This seems complex, but it mirrors the
	complexity inherent in the problem.  The problem solver must
	make choices about how to investigate the effects of changes
	in assumption.  The medium is merely reifying the choices that
	have to be made to support those inferences.  The benefit of
	the medium is that it will help do the computational work in
	making those inferences, and help track their impact.
      </p>

	<h3>Outlook</h3>

      <p>
	In discussions of systems of reasoning it is sometimes assumed
	that the informal, intuitive systems used by humans are things
	to be &ldquo;fixed up&rdquo;, turned into so-called proper,
	rigorous reasoning.  If the purpose of reasoning were merely
	verifying correctness, then that would be a reasonable point
	of view.  But if the purpose of reasoning is exploration and
	discovery, then it is wrong.  Exploration and discovery
	require a logic that is different to, and at least as valuable
	as, conventionally &ldquo;correct&rdquo; reasoning.  The idea
	of semi-concrete reasoning is a step toward media to support
	such exploration and discovery, and perhaps toward new ways of
	thinking about mathematics.
      </p>

      <p>
	<a href="refs/Kay2013.pdf">Alan Kay has asked</a> &ldquo;what
	is the carrying capacity for ideas of the computer?&rdquo; We
	may also ask the closely related question: &ldquo;what is the
	carrying capacity for <em>discovery</em> of the
	computer?&rdquo; In this essay we've made progress on that
	question using a simple strategy: develop a prototype medium
	to represent mathematics in a new way, and carefully
	investigate what we can learn when we use the prototype to
	attack a serious mathematical problem.  In future, it'd be of
	interest to pursue a similar strategy with other problems, and
	with more adventurous interface ideas.  And, of course, it
	would be of interest to build out a working system that
	develops the best ideas fully, not merely prototypes.
      </p>

      <p>
	To conclude, a personal observation.  I began thinking about
	the design of cognitive media just a few years ago.  I've
	repeatedly found that interface design is deeper than I
	suspected.  A powerful medium reifies the deepest ideas we
	have about a subject: it becomes an active carrier for those
	ideas.  And to the extent it is successful in reifying those
	ideas, mastering the medium becomes the same as mastering the
	subject.  In this view, designing exploratory media is about
	designing tools which can transform and extend our ability to
	think, create, and discover.
      </p>

      <p>
	<em><strong>Acknowledgments:</strong> Thanks to Dave Albert,
	  Darius Bacon, Kovas Boguta, Ilona Brand, Joe Edelman, Jesse
	  Tasse Gonzalez, Max McCrea, Chris Olah, Prabhakar Ragde,
	  Omar Rizwan, John Workman, Katherine Ye, and Devon Zuegel
	  for helpful conversations and for comments on a draft of
	  this essay.</em>
      </p>

	
      <p><a name="appA"></a>
	<h2>Appendix A: the proof of the SVD in $n$
	dimensions</h2>
      </p>

      <p>
	In the main body of the essay we learned how to prove the
	singular value decomposition in 2 dimensions.  In fact, the
	same ideas can be used to prove the SVD in $n$ dimensions.
	I'll briefly sketch how the proof works in this appendix.  It
	begins with exactly the same argument as we used earlier,
	showing that if $s$ is the principal right singular vector of
	$M$, and $t$ is any vector orthonormal to $s$, then $Ms$ is
	orthogonal to $Mt$.  No modification is needed to establish
	this &ndash; the proof goes straight through.
      </p>

      <p>
	From this, it can be shown using a construction similar to the
	$2 \times 2$ case that
      </p>

      <p>
	$$M = U_1 \begin{bmatrix} s_1 & 0 \\ 0 & M' \end{bmatrix} V_1$$
      </p>

      <p>
	where $U_1$ and $V_1$ are orthogonal matrices, and $M'$ is an
	$n-1$ by $n-1$ submatrix.  Proving this is pretty
	straightforward, although it may be tedious if you're not so
	comfortable with linear algebra.  The only real difference is
	that instead of working with a vector $t$ tangent to the
	principal right singular vector $s$, we instead work with the
	entire vector subspace tangent to $s$. I won't go through the
	details.
      </p>

      <p>
	We can repeat this decomposition, breaking $M'$ up in terms of
	orthogonal matrices in $n-1$ dimensions and an $n-2$ by $n-2$
	submatrix $M''$.  Continuing in this way until we reach two
	dimensions, we obtain
      </p>

      <p>
	$$M = U_1 U_2 \ldots {\rm diag}(s_1, s_2, \ldots, s_n) \ldots V_2 V_1,$$
      </p>

      <p>
	where $U_1, V_1, U_2, V_2, \ldots$ are all orthogonal
	matrices.  Since a product of orthogonal matrices is itself an
	orthogonal matrix, we obtain
      </p>

      <p>
	$$M = U \, {\rm diag}(s_1, s_2, \ldots, s_n) \, V$$
      </p>

      <p>
	for orthogonal matrices $U$ and $V$. This is the singular
	value decomposition.
      </p>

      <p>
	It's notable that we developed the ideas underlying this proof
	in a visual environment depicting two spatial dimensions.
	We've then used algebraic-and-textual reasoning to extend that
	intuition to higher dimensions.  This is a common procedure in
	paper-and-pencil based mathematical reasoning.  Mathematicians
	develop fairly sophisticated ways of using informal
	two-dimensional representations to support more rigorous
	$n$-dimensional reasoning.  Consider, for example, the
	following <a href="http://mathoverflow.net/a/26010">remark by
	mathematician Gil Kalai</a> on high-dimensional reasoning:
      </p>

      <p>
	<img src="images/milman.jpg" width="200px;" style="float:
	right; margin-left: 10px;"/>
	<em>Vitali Milman, who works in high-dimensional convexity, likes
	to draw high-dimensional convex bodies in a non-convex way.
	This is to convey the point that if you take the convex hull
	of a few points on the unit sphere of $R^n$, then for large
	$n$ very little of the measure of the convex body is anywhere
	near the corners, so in a certain sense the body is a bit like
	a small sphere with long thin &ldquo;spikes&rdquo;.
	</em>
      </p>

      <p>
	A powerful exploratory medium for mathematics would build in
	such representational ideas, and would understand how to use
	them to support the transition from informal reasoning about
	low-dimensional representations to rigorous high-dimensional
	proofs.
      </p>

      
      <p><a name="appB"></a>
	<h2>Appendix B: finding the maximal stretching for a matrix</h2>
      </p>

      <p>
	Our earlier discussion showed that the largest singular value
	$s_1$ for a $2 \times 2$ matrix $M$ is equal to the maximal
	degree of stretching $\|Ms\|$. In fact, it's straightforward
	to adapt the reasoning in Appendix A to show that this is true
	also for an $n \times n$ matrix.  That is, suppose an $n
	\times n$ matrix $M$ has singular value decomposition
      </p>

      <p>
	$$M = U \,\mbox{diag}(s_1, s_2, \ldots, s_n) V,$$
      </p>

      <p>
	with singular values $s_1 \geq s_2 \geq \ldots \geq s_n \geq
	0$.  Then the maximal degree of stretching is just
      </p>

      <p>
	$$\max_{\|v \| = 1} \| Mv \| = s_1.$$
      </p>

      <p>
	While this is a nice connection, it's not obvious it helps us
	figure out the maximal degree of stretching.  After all, at
	this point we haven't figured out an explicit way of computing
	the singular values for a given matrix $M$. Fortunately, with
	a little work we can figure out not just $s_1$, but all the
	singular values.  To do this, observe that from the SVD we
	have
      </p>

      <p>
	$$M^T M = V^T \mbox{diag}(s_1^2, s_2^2, \ldots, s_n^2) V$$
      </p>

      <p>
	since $U$ is an orthogonal matrix, and thus satisfies $U^T U =
	I$.  Inspecting this equation, we see that the eigenvalues of
	$M^TM$ are just the squares of the singular values, $s_1^2,
	s_2^2, \ldots$.  And so $s_1$ is just the square root of the
	largest eigenvalue of $M^TM$.  This eigenvalue <em>is</em>
	easy to compute, which makes the singular value $s_1$ easy to
	compute.  And that, in turn, makes it easy to compute the
	maximal degree of stretching for $M$.
      </p>

      <p>
	Summing up, the maximal degree of stretching for a matrix $M$
	is equal to the square root of the largest eigenvalue of
	$M^TM$.  This gives an easy, computationally feasible way of
	computing the maximal degree of stretching, and thus solves
	our original problem.  This also illustrates a point made when
	we first discussed the SVD: knowing the SVD is true sometimes
	makes it much easier to reason about a matrix.
      </p>

    </div>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44208967-4', 'auto');
  ga('send', 'pageview');

</script>
</body>

</html>


